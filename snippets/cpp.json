{
  "try": {
    "prefix": "try",
    "body": ["try {", "} catch (const std::exception &e) {", "}", ""]
  },
  "resp": {
    "prefix": "resp",
    "body": [
      "auto resp = HttpResponse::newHttpJsonResponse(response);",
      "resp->setStatusCode(k200OK);",
      "callback(resp);"
    ]
  },
  "fetch": {
    "prefix": "fetch",
    "body": [
      "cpr::Header headers = {",
      "  {\"Content-Type\", \"application/json\"}",
      "};",
      "cpr::Body body = cpr::Body{R\"({\"key\": \"value\"})\"};",
      "std::future<cpr::Response> ${1:res}Fut =",
      "    std::async(std::launch::async, [headers, body]() {",
      "      return cpr::Post(",
      "          cpr::Url{\"${2:https://url.com/\"}},",
      "          headers,",
      "          body);",
      "    });",
      "",
      "auto ${1:res} = ${1:res}Fut.get();",
      "",
      "Json::Value response;",
      "if (res.status_code == 200) {",
      "  Json::CharReaderBuilder builder;",
      "  Json::Value json;",
      "  std::string errs;",
      "  std::unique_ptr<Json::CharReader> reader(builder.newCharReader());",
      "",
      "  if (reader->parse(res.text.c_str(),",
      "                    res.text.c_str() + res.text.length(), &json,",
      "                    &errs)) {",
      "    response[\"status\"] = \"success\";",
      "    response[\"repository\"] = json[\"name\"];",
      "  } else {",
      "    response[\"status\"] = \"error\";",
      "    response[\"error\"] =",
      "        \"Failed to parse GitHub API response: \" + errs;",
      "  }",
      "} else {",
      "  response[\"status\"] = \"error\";",
      "  response[\"error\"] = \"GitHub API request failed\";",
      "  response[\"status_code\"] = static_cast<int>(res.status_code);",
      "}",
      ""
    ]
  },
  "route": {
    "prefix": "route",
    "body": [
      "// CMakeLists.txt",
      "add_executable(\\${PROJECT_NAME} ",
      "    ...",
      "    routes/${1:routeName}.cpp",
      "    ...",
      ")",
      "",
      "routes/${1:routeName}.cpp",
      "",
      "",
      "//${1:routeName}.cpp",
      "#include \"${1:routeName}.h\"",
      "#include <drogon/drogon.h>",
      "",
      "using namespace drogon;",
      "using namespace std;",
      "",
      "Task<HttpResponsePtr> ${1:routeName}Controller::${1:routeName}(HttpRequestPtr req,",
      "                                             string name) {",
      "  Json::Value response;",
      "  response[\"${1:routeName}\"] = \"${1:routeName} \" + name;",
      "",
      "  auto resp = HttpResponse::newHttpJsonResponse(response);",
      "  resp->setStatusCode(k200OK);",
      "  co_return resp;",
      "}",
      "",
      "// ${1:routeName}.h",
      "#pragma once",
      "#include <drogon/HttpController.h>",
      "#include <string>",
      "",
      "using namespace drogon;",
      "using namespace std;",
      "class ${1:routeName}Controller : public HttpController<${1:routeName}Controller> {",
      "public:",
      "  METHOD_LIST_BEGIN",
      "  ADD_METHOD_TO(${1:routeName}Controller::${1:routeName}, \"/${1:routeName}/{name}\", Get);",
      "  METHOD_LIST_END",
      "",
      "  static Task<HttpResponsePtr> ${1:routeName}(HttpRequestPtr req, string name);",
      "};",
      ""
    ]
  }
}
